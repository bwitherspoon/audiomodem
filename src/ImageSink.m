% Copyright (c) 2015, C. Brett Witherspoon <cbwithersp42@students.tntech.edu>
% 
% Permission to use, copy, modify, and/or distribute this software for any
% purpose with or without fee is hereby granted, provided that the above
% copyright notice and this permission notice appear in all copies.
% 
% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

classdef ImageSink < matlab.System
    % A class for receiving packets generated by the ImageSource class.
    %
    % The input should be a column vector of bits.
    %
    % See README.md for details.

    properties (Nontunable)
        Verbose = false
    end

    properties (Access=private)
        Init
        Data
        Offset
        HeaderLength
        Deserializer
        CRC
    end

    properties (Constant)
        HeaderCount = 2
        HeaderWordSize = 16
    end

    methods
        function obj = ImageSink(varargin)
            setProperties(obj,nargin,varargin{:});
            obj.HeaderLength = 3*obj.HeaderWordSize*obj.HeaderCount;
            obj.CRC = comm.CRCDetector(...
                'Polynomial', [32 26 23 22 16 12 11 10 8 7 5 4 2 1 0]);
        end
    end

    methods (Access=protected)
        function resetImpl(obj)
            obj.Init = 1;
            obj.Offset = 0;
        end

        function releaseImpl(obj)
            obj.Init = 1;
            obj.Offset = 0;
            obj.Data = [];
        end

        function valid = verifyHeader(obj, header)
            valid = true;
            % Check that all headers are equal
            for ii = 0:obj.HeaderCount-2
                if sum(header(3*ii+1:3*ii+3) ~= header(3*ii+4:3*ii+6))
                    valid = false;
                    return;
                end
            end
            % Check that third size dimension is 1, 3, or 4
            for ii = 1:obj.HeaderCount
                if ~any(header(3*ii) == [1, 3, 4])
                    valid = false;
                    return;
                end
            end
        end

        function complete = stepImpl(obj, stream)
            complete = false;
            if obj.Init
                % Extract header
                header = stream(1:obj.HeaderLength);
                header = Serdes.BitStreamToWords(header, obj.HeaderWordSize);
                % Verify header
                if ~obj.verifyHeader(header)
                    if obj.Verbose
                        fprintf('Rejecting packet due to corrupt header...\n');
                    end
                    return
                end
                % Extract shape from header
                shape = header(1:3)';
                % Create deserializer
                obj.Deserializer = Serdes(shape);
                % Allocate storage for data and checksum (32 bits)
                nbytes = prod(shape);
                obj.Data = false(8*nbytes+32, 1); % logical array for bits
                fprintf('Receiving %d bytes...\n', nbytes);
                % Truncate header
                stream = stream(obj.HeaderLength+1:end);
                % Exit initial state
                obj.Init = 0;
            end
            % Copy data to storage
            n = min(obj.Offset+length(stream), length(obj.Data));
            obj.Data(obj.Offset+1:n) = stream(1:n-obj.Offset);
            obj.Offset = n;
            if obj.Verbose
                fprintf('Received %d bytes...\r', obj.Offset/8);
            end
            % Verify and display if transfer is complete
            if obj.Offset == length(obj.Data)
                complete = true;
                % Check CRC-32 checksum
                [data, err] = obj.CRC.step(obj.Data);
                if err
                    warning('Received image is corrupt')
                end
                % Deserialize image
                img = obj.Deserializer.Deserialize(data);
                imshow(img);
                % Reset state
                obj.Init = 1;
                obj.Offset = 0;
            end
        end
    end
end

